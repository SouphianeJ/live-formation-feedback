import fs from "fs";
import path from "path";

const root = process.cwd();
const sourcePath = path.join(root, "QuestionnaireExemple.md");
const outputPath = path.join(root, "scripts", "seed_questionnaire_example.mongosh.js");
const envPath = path.join(root, ".env");

function loadEnv(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const content = fs.readFileSync(filePath, "utf8");
  const env = {};
  for (const line of content.split(/\r?\n/)) {
    if (!line || line.trim().startsWith("#")) continue;
    const match = line.match(/^([A-Z0-9_]+)=(.*)$/);
    if (!match) continue;
    let value = match[2];
    if (value.startsWith('"') && value.endsWith('"')) {
      value = value.slice(1, -1);
    }
    env[match[1]] = value;
  }
  return env;
}

const env = loadEnv(envPath);
const baseUrl = (env.APP_BASE_URL || "http://localhost:3000").replace(/\/$/, "");

const raw = fs.readFileSync(sourcePath);
let text = raw.toString("utf8");
text = text.replace(/\r\n/g, "\n");

const lines = text
  .split("\n")
  .map((line) => line.trim())
  .filter((line) => line.length > 0);

const domains = [];
let currentDomain = null;
let currentQuestion = null;

function splitDomainLine(line) {
  const normalized = line.replace(/[–—]/g, "-");
  const match = normalized.match(/^Domaine\s+(\d+)\s+-\s+(.+?)\s*\(([^)]+)\)\s*$/i);
  if (!match) return null;
  return {
    order: Number(match[1]),
    name: match[2].trim(),
    code: match[3].trim(),
  };
}

for (const rawLine of lines) {
  const domainInfo = splitDomainLine(rawLine);
  if (domainInfo) {
    currentDomain = {
      order: domainInfo.order,
      name: domainInfo.name,
      description: domainInfo.code,
      questions: [],
    };
    domains.push(currentDomain);
    currentQuestion = null;
    continue;
  }

  const questionMatch = rawLine.match(/^([A-Z])\d+\.\s*(.+)$/);
  if (questionMatch && currentDomain) {
    const prompt = questionMatch[2].trim();
    currentQuestion = {
      prompt,
      helpText: "",
      type: "single-choice",
      order: currentDomain.questions.length + 1,
      isRequired: true,
      answers: [],
    };
    currentDomain.questions.push(currentQuestion);
    continue;
  }

  const answerMatch = rawLine.match(/^([A-E])\.\s*(.+)$/);
  if (answerMatch && currentQuestion) {
    const value = answerMatch[1];
    const label = answerMatch[2].trim();
    const scoreMap = { A: 4, B: 3, C: 2, D: 1, E: 0 };
    currentQuestion.answers.push({
      value,
      label,
      score: scoreMap[value],
      order: currentQuestion.answers.length + 1,
    });
  }
}

const questionnaire = {
  title: "Questionnaire exemple",
  description: "Importé depuis QuestionnaireExemple.md",
  slug: "questionnaire-exemple",
  status: "published",
};

const resourceMap = {
  DESIGN: "CM_DESIGN.pptx",
  DYNAMIQUE: "CM_DYNAMIQUE.pptx",
  MICRO: "CM_MICRO.pptx",
  ACTIVE: "CM_ACTIVE.pptx",
  FEEDBACK: "CM_FEEDBACK.pptx",
  TECH: "CM_TECH.pptx",
};

const linesOut = [];
linesOut.push("// Generated by scripts/seed_from_questionnaire_example.mjs");
linesOut.push("const dbName = \"appdev\";");
linesOut.push("const dbRef = db.getSiblingDB(dbName);");
linesOut.push("const now = new Date();");
linesOut.push("\n// Cleanup existing questionnaire by slug");
linesOut.push(`const existing = dbRef.Questionnaire.findOne({ slug: ${JSON.stringify(questionnaire.slug)} }, { _id: 1 });`);
linesOut.push("if (existing) {");
linesOut.push("  const domainIds = dbRef.Domain.find({ questionnaireId: existing._id }, { _id: 1 }).toArray().map(d => d._id);");
linesOut.push("  const questionIds = dbRef.Question.find({ domainId: { $in: domainIds } }, { _id: 1 }).toArray().map(q => q._id);");
linesOut.push("  if (questionIds.length) dbRef.AnswerOption.deleteMany({ questionId: { $in: questionIds } });");
linesOut.push("  if (domainIds.length) dbRef.Resource.deleteMany({ domainId: { $in: domainIds } });");
linesOut.push("  if (domainIds.length) dbRef.Question.deleteMany({ domainId: { $in: domainIds } });");
linesOut.push("  if (domainIds.length) dbRef.Domain.deleteMany({ _id: { $in: domainIds } });");
linesOut.push("  dbRef.Questionnaire.deleteOne({ _id: existing._id });");
linesOut.push("}");

linesOut.push("\n// Questionnaire");
linesOut.push(`const questionnaire = dbRef.Questionnaire.insertOne({\n  title: ${JSON.stringify(questionnaire.title)},\n  description: ${JSON.stringify(questionnaire.description)},\n  slug: ${JSON.stringify(questionnaire.slug)},\n  status: ${JSON.stringify(questionnaire.status)},\n  createdAt: now,\n  updatedAt: now,\n});`);

linesOut.push("\n// Domains, Resources, Questions, Answers");

for (const domain of domains) {
  linesOut.push(`const domain${domain.order} = dbRef.Domain.insertOne({\n  questionnaireId: questionnaire.insertedId,\n  name: ${JSON.stringify(domain.name)},\n  description: ${JSON.stringify(domain.description || "")},\n  order: ${domain.order},\n  createdAt: now,\n  updatedAt: now,\n});`);

  const resourceFile = resourceMap[domain.description];
  if (resourceFile) {
    const resourceUrl = `${baseUrl}/${resourceFile}`;
    linesOut.push(`dbRef.Resource.insertOne({\n  domainId: domain${domain.order}.insertedId,\n  title: ${JSON.stringify(`Support ${domain.description}`)},\n  type: ${JSON.stringify("pptx")},\n  url: ${JSON.stringify(resourceUrl)},\n  order: 1,\n});`);
  }

  let qIndex = 0;
  for (const question of domain.questions) {
    qIndex += 1;
    linesOut.push(`const q_${domain.order}_${qIndex} = dbRef.Question.insertOne({\n  domainId: domain${domain.order}.insertedId,\n  type: ${JSON.stringify(question.type)},\n  prompt: ${JSON.stringify(question.prompt)},\n  helpText: ${JSON.stringify(question.helpText || "")},\n  order: ${question.order},\n  isRequired: ${question.isRequired ? "true" : "false"},\n  createdAt: now,\n  updatedAt: now,\n});`);

    for (const answer of question.answers) {
      linesOut.push(`dbRef.AnswerOption.insertOne({\n  questionId: q_${domain.order}_${qIndex}.insertedId,\n  value: ${JSON.stringify(answer.value)},\n  label: ${JSON.stringify(answer.label)},\n  score: ${answer.score},\n  order: ${answer.order},\n});`);
    }
    linesOut.push("");
  }
}

linesOut.push("\nprint(\"Seed terminé\");");

fs.writeFileSync(outputPath, linesOut.join("\n"), "utf8");
console.log(`Generated ${outputPath}`);
